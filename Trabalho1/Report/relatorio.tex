\documentclass[pdftex,12pt,a4paper]{report}

\usepackage[portuguese,english]{babel}
\usepackage[T1]{fontenc} 
\usepackage[table]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage{minitoc}
\usepackage{hyperref}
\usepackage{indentfirst}
\usepackage[compact]{titlesec}
\usepackage{fancyhdr}
\usepackage{caption}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{fixltx2e}
\usepackage{mathtools}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{color}
\usepackage{sverb}
\usepackage[section]{placeins}
%Highlight
\newcommand{\shellcmd}[1]{\\\indent\indent\texttt{\footnotesize\# #1}\\}

\pagestyle{fancy}
\renewcommand*\thesection{\thechapter\arabic{section}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\begin{document}

\input{./titulo.tex} %Titulo do Relatorio
\renewcommand{\headrulewidth}{0pt}

%Cabeçalhos de rodapé
\fancyhead{}
\fancyfoot{}
\lhead{Home group assignment 1}
\rhead{ACA - 2015/2016}
\lfoot{Rafael Ferreira nmec: 67405 \\ Rodrigo Cunha nmec: 67800}
\rfoot{\thepage}

%Renomear Comandos
\renewcommand*\contentsname{Conteúdos}
\renewcommand*\figurename{Figura}
\renewcommand*\tablename{Tabela}

%Conteúdos, dar paragrafo
\tableofcontents
%Headers
\renewcommand{\headrulewidth}{0.15pt}
\renewcommand{\thechapter}{}

\clearpage

\section{Introdução}
% o que, porquê e o objetivo

FALTAAAAAAAAAA

O trabalho proposto para o projeto da unidade curricular de Segurança é um IEDCS: Identity Enabled Distribution Control System. Para o  efeito foi necessário implementar uma Ebook Webstore, um WebService e um Player de reprodução dos Ebooks em formato de texto.

O objetivo deste sistema é garantir a máxima e possível segurança do serviço, utilizando os conhecimentos adquiridos na unidade curricular de Segurança. Para isso são necessários vários processos como por exemplo, a utilização de certificados HTTPS, a cifragem de todo o material existente, derivação de chaves e registo de utilizadores.	

O relatório reflete todos os passos e decisões tomadas na criação do sistema, assim como uma análise ao que foi mostrado na primeira apresentação e decisões que se tomaram depois desta, tecnologias utilizadas, descrição dos vários processos existentes e conclusão.

\newpage
\section{Exercício 1}

\subsection{Divisão da fase ID em duas fases ID1/ID2}
Neste primeiro exercício, era pedido que se fizesse a divisão da fase ID, por duas fases ID1 e ID2.

\begin{figure}[!htb]
\center
 \includegraphics[width=100mm,scale=1]{ID1ID2ex1.pdf}
 \caption{\\ Registo ID1/ID2}
 \label{fig:ex1RegID1ID2}
\end{figure}

O inicio da leitura de registos tem inicio em ID1 e termina em ID2 (como podemos verificar na figura 1), sendo que na fase ID1 também é feito o decode da instrução para obter os sinais de rs, rt, rd, funct, opcode e immed.  Tudo o que se resolvia em ID agora resolve-se em ID2, como por exemplo a unidade de Controlo, o extend e o Mux entre o rt e o rd.

Para este primeiro exercício criou-se um registo novo ID1/ID2, que toma como entradas o \textit{opcode}, o \textit{funct}, o \textit{immed}, o \textit{rt}, o \textit{rs} e o \textit{rd} vindos do decoder de ID1, sendo as saídas as correspondentes a estas mesmas portas. Existe também uma entrada vinda da unidade de Hazard, \textit{reset\_id1id2}, para fazer reset a este registo aquando da necessidade de existirem stalls ou branchs.

Na unidade de hazard foram feitas algumas alterações para que estes fossem resolvidos em ID2, que anteriormente eram resolvidos em ID. A única diferença é que são os registos em ID2, rs e rt, que definem a existência de hazard tendo em conta as fases mais avançadas da pipeline, como EXE, MEM e WB.

\newpage
\section{Exercício 2}

Neste segundo exercício, foi-nos proposto para que todos os saltos condicionais e incondicionais, fossem resolvidos em ID2. Para isso foi criada uma unidade de branch, que através de entradas como \textit{opcode}, \textit{rsdata}, \textit{rtdata}, \textit{branch}, \textit{target}, \textit{imm\_ext} e \textit{PC4}, calcula o \textit{branchTaken}, que nos diz se existe salto ou não, e o \textit{branchTarget} (Figura 2).

\begin{figure}[!htb]
\center
 \includegraphics[width=100mm,scale=1]{ID1ID2ex2.pdf}
 \caption{\\Registo ID1ID2 com Branch Unit}\label{fig:ex2RegID1ID2}
\end{figure}

\subsection{Unidade de Branch}

Para que os saltos fossem resolvidos em ID2, foi necessário na unidade de branch resolver os mesmos. Para isto dentro da unidade de controlo, alterou-se a informação que a saída de branch possuí. Disponibilizaram-se mais bits para que esta saída indique na unidade de branch o tipo de salto que estamos a resolver.

Posto isto na unidade de branch, efectuam-se 6 casos diferentes:

\begin{itemize}
\item BEQ: compara se o valor de \textit{rsdata} é igual ao de \textit{rtdata}
\item BNE: compara se o valor de \textit{rsdata} é diferente de \textit{rtdata} 
\item BGTZ: compara se o valor de \textit{rsdata} é maior que zero
\item BLEZ: compara se o valor de \textit{rsdata} é menor ou igual a zero
\item JUMP: salta para o target da instrução
\item JR: salta para o valor de \textit{rsdata}
\end{itemize} 

Sendo os saltos resolvidos em ID2, foram removidos de fases mais avançadas unidades que não seriam mais utilizadas, como por exemplo o \textit{sl2} e a unidade de adição para branch em EXE e o \textit{and} em MEM. Os portos \textit{PC4} e \textit{branch} também deixaram de ser propagados para as fases seguintes à ID2.

\subsection{Unidade de Hazard adaptada para a nova resolução de saltos}

Para que instruções que entrem de forma errada na pipeline quando um branch ocorre sejam descartadas excepto a seguinte (delayed branch slot), foi necessário alterar na unidade de Hazard as fases às quais é necessário fazer reset. Desta feita quando a nossa unidade de Hazard trata de descartar instruções que entrem de forma errada na pipeline e de colocar stalls aquando da ocorrência destes.

\section{Forwarding}

Na tarefa 3 foi-nos pedido para identificar quais são os tipos de forwarding que podem ocorrer na nossa arquitectura onde a origem dos valores são os valores dos registos da pipeline e o seu destino é a "stage".

Os tipos de forwarding são:
\begin{itemize}
\item EXE/MEM->EXE
\item EXE/MEM->ID2
\item MEM/WB->EXE
\item MEM/WB->ID2
\item MEM/WB->MEM
\end{itemize} 

\newpage

\begin{figure}[!htb]
\center
 \includegraphics[width=150mm,scale=1]{path.pdf}
 \caption{\\ Forwarding path}
 \label{fig:path}
\end{figure}

\subsection{EXE/MEM->EXE}

\begin{table}[!htb]
\centering
\label{my-label}
\begin{tabular}{cc|c|c|
>{\columncolor[HTML]{F8A102}}c |
>{\columncolor[HTML]{FFCC67}}c |c|ccl}
\cline{2-7}
\multicolumn{1}{c|}{add \$1, \$2, \$3} & IF & ID1 & ID2 & EXE                                                & MEM                         & WB  &                         &  &  \\ \cline{2-8}
lw \$2, 0(\$1)                         &    & IF  & ID1 & \cellcolor[HTML]{FFFFFF}{\color[HTML]{000000} ID2} & \cellcolor[HTML]{F8A102}EXE & MEM & \multicolumn{1}{c|}{WB} &  &  \\ \cline{3-8}
\end{tabular}
\end{table}

\begin{table}[!htb]
\centering
\label{for_ex_mem_exe}
\begin{tabular}{ll|c|c|l|
>{\columncolor[HTML]{FFCC67}}c |c|l}
\cline{2-7}
\multicolumn{1}{l|}{add \$1, \$2, \$3} & \multicolumn{1}{c|}{IF} & ID1 & ID2 & \multicolumn{1}{c|}{\cellcolor[HTML]{F8A102}EXE} & MEM                                                & WB  &                         \\ \cline{2-8} 
sub \$2, \$1, \$3                      &                         & IF  & ID1 & ID2                                              & \cellcolor[HTML]{F8A102}{\color[HTML]{333333} EXE} & MEM & \multicolumn{1}{c|}{WB} \\ \cline{3-8} 
\end{tabular}
\end{table}

Este tipo de forwarding é causado por uma instrução que escreva num registo e de seguida uma outra instrução precise desse registo para realizar uma operação, ou seja, precisa de ler esse registo. Por exemplo, podemos ter um add \$1, \$2, \$3 e depois um sub \$2, \$1, \$3, a primeira instrução escreve em \$1 e a segunda instrução precisa do \$1  para realizar a operação de sub com \$3.
\linebreak

Tanto para RS e RT em ID2 comparamos com o WriteReg, se o registo RS/RT em ID2 é diferente de 0 e se vai escrever no registo ambos em EXE. 
Caso esta condição seja verdadeira, vamos então mudar o sinal de seleção do multiplexer para 1, sendo este sinal o que vai selecionar no mux o valor da entrada da ALU como "rs/rt".

Teve-se em atenção que o rt quando MemRead é verdadeiro é porque se vai escrever em rt, e o que nós queremos é ler em rt e não escrever em rt por isso adicionou-se a condição para que MemRead seja igual a false.
\linebreak

\begin{lstlisting}[language=c]
if(rs_id2.read()!=0 && rs_id2.read()==WriteReg_exe.read() 
	&& RegWrite_exe.read()==true){
    rsmux_exe.write(1); 
}
if(rt_id2.read()!=0 && rt_id2.read()==WriteReg_exe.read() 
	&& RegWrite_exe.read()==true 
	&& MemRead.read()==false){
   rtmux_exe.write(1);
}
\end{lstlisting} 

\subsection{EXE/MEM->ID2}

\begin{table}[!htb]
\centering
\label{table_exe_mem_id2}
\begin{tabular}{ccc|c|c|c|c|cc}
\cline{2-7}
\multicolumn{1}{c|}{add \$1, \$2, \$3} & \multicolumn{1}{c|}{IF} & ID1 & ID2 & \cellcolor[HTML]{F8A102}EXE                        & \cellcolor[HTML]{FFCC67}MEM                        & WB  &                          &                         \\ \cline{2-8}
nop                                  & \multicolumn{1}{c|}{}   & IF  & ID1 & \cellcolor[HTML]{FFFFFF}{\color[HTML]{000000} ID2} & \cellcolor[HTML]{FFFFFF}{\color[HTML]{333333} EXE} & MEM & \multicolumn{1}{c|}{WB}  &                         \\ \cline{3-9} 
beq \$1, \$0, label                      &                         &     & IF  & ID1                                                & \cellcolor[HTML]{F8A102}{\color[HTML]{333333} ID2} & EXE & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB} \\ \cline{4-9} 
\end{tabular}
\end{table}

Este tipo de forwarding é causado por uma instrução que escreva num registo para o qual um branch condicional necessite de ler esse registo para tomar uma decisão. Por exemplo, neste caso, tem-se uma instrução add \$1, \$2, \$3 que vai escrever em \$1 e o beq vai necessitar de \$1 para calcular a decisão, neste caso é o \$rs mas também podia ser o \$rt o registo necessário para calcular a decisão que estivesse a ser escrito por uma outra instrução. É feito então o forwarding da fase EXE/MEM para ID2.

Nas condições que usamos para detetar estes casos de forwarding comparamos o rs/rt em id2 com o WriteReg em EXE, se vai escrever no registo em EXE e se é uma branch, ou seja, branch tem de ser diferente de 0, isto deve-se porque no exercício anterior colocou-se o sinal de branch a ter valores de 0 a 6. O multiplexer vai selecionar o forward de EXE/MEM para esta fase, fazendo com que os valores sejam selecionados os que está a ser feito o forward e não os que saiem dos registos.

\begin{lstlisting}[language=c]
if(rs_id2.read()!=0 && rs_id2.read()==WriteReg_exe.read() 
	&& RegWrite_exe.read()==true && branch.read()!=0){
    rsmux_id2.write(1);
}
if(rt_id2.read()!=0 && rt_id2.read()==WriteReg_exe.read() 
	&& RegWrite_exe.read()==true 
	&& branch.read()!=0 
	&& MemRead.read()==false){
   rtmux_id2.write(1);
}
\end{lstlisting} 


\subsection{MEM/WB->EXE}

\begin{table}[!htb]
\centering
\label{my-label}
\begin{tabular}{ccc|c|c|c|c|cc}
\cline{2-7}
\multicolumn{1}{c|}{lw \$1, 0(\$0)} & \multicolumn{1}{c|}{IF} & ID1 & ID2 & EXE                                                & \cellcolor[HTML]{F8A102}MEM                        & \cellcolor[HTML]{FFCC67}WB  &                          &                         \\ \cline{2-8}
nop                               & \multicolumn{1}{c|}{}   & IF  & ID1 & \cellcolor[HTML]{FFFFFF}{\color[HTML]{000000} ID2} & \cellcolor[HTML]{FFFFFF}{\color[HTML]{333333} EXE} & MEM                         & \multicolumn{1}{c|}{WB}  &                         \\ \cline{3-9} 
add \$2, \$1, \$1                   &                         &     & IF  & ID1                                                & ID2                                                & \cellcolor[HTML]{F8A102}EXE & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB} \\ \cline{4-9} 
\end{tabular}
\end{table}

\begin{table}[!htb]
\centering
\label{my-label}
\begin{tabular}{ccc|c|c|c|c|cc}
\cline{2-7}
\multicolumn{1}{c|}{add \$1, \$0, \$0} & \multicolumn{1}{c|}{IF} & ID1 & ID2 & EXE                                                & \cellcolor[HTML]{F8A102}MEM                        & \cellcolor[HTML]{FFCC67}WB  &                          &                         \\ \cline{2-8}
nop                                  & \multicolumn{1}{c|}{}   & IF  & ID1 & \cellcolor[HTML]{FFFFFF}{\color[HTML]{000000} ID2} & \cellcolor[HTML]{FFFFFF}{\color[HTML]{333333} EXE} & MEM                         & \multicolumn{1}{c|}{WB}  &                         \\ \cline{3-9} 
add \$2, \$1, \$1                      &                         &     & IF  & ID1                                                & ID2                                                & \cellcolor[HTML]{F8A102}EXE & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB} \\ \cline{4-9} 
\end{tabular}
\end{table}

\begin{table}[!htb]
\centering
\begin{tabular}{ccc|c|c|c|c|cc}
\cline{2-7}
\multicolumn{1}{c|}{lw \$1, 0(\$0)} & \multicolumn{1}{c|}{IF} & ID1 & ID2 & EXE                                                & \cellcolor[HTML]{F8A102}MEM                        & \cellcolor[HTML]{FFCC67}WB  &                          &                         \\ \cline{2-8}
nop                               & \multicolumn{1}{c|}{}   & IF  & ID1 & \cellcolor[HTML]{FFFFFF}{\color[HTML]{000000} ID2} & \cellcolor[HTML]{FFFFFF}{\color[HTML]{333333} EXE} & MEM                         & \multicolumn{1}{c|}{WB}  &                         \\ \cline{3-9} 
lw \$1, 0(\$1)                      &                         &     & IF  & ID1                                                & ID2                                                & \cellcolor[HTML]{F8A102}EXE & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB} \\ \cline{4-9} 
\end{tabular}
\end{table}

Este tipo de forwarding é provocado por uma instrução do que escreva para um registo que uma terceira instrução na pipeline necessite de ler para efetuar a sua operação em EXE. 

Por exemplo, no nosso caso temos uma operação do tipo LW que lê na memória para o registo \$1, e depois, duas em EXE existe uma instrução que vai ler do registo que foi escrito pela instrução LW. Assim como podemos ter uma instrução do tipo R na fase MEM e uma instrução do tipo R que também necessite desse registo escrito pela primeira instrução na fase EXE. 

\begin{lstlisting}[language=c]
if(rs_id2.read()!=0 && rs_id2.read()==WriteReg_mem.read()
  && RegWrite_mem.read()==true){
    rsmux_exe.write(2);
}
if(rt_id2.read()!=0 && rt_id2.read()==WriteReg_mem.read() 
  && RegWrite_mem.read()==true 
  && MemRead.read()==false){
    rtmux_exe.write(2);
}
\end{lstlisting} 

\subsection{MEM/WB->ID2}

\begin{table}[!htb]
\centering
\label{my-label}
\begin{tabular}{cccc|c|c|c|ccl}
\cline{2-7}
\multicolumn{1}{c|}{lw \$1, 0(\$0)}     & \multicolumn{1}{c|}{IF} & \multicolumn{1}{c|}{ID1} & ID2                   & EXE                                                & \cellcolor[HTML]{F8A102}MEM                        & \cellcolor[HTML]{FFCC67}WB  &                          &                          &                         \\ \cline{2-8}
nop                                   & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{IF}  & ID1                   & \cellcolor[HTML]{FFFFFF}{\color[HTML]{000000} ID2} & \cellcolor[HTML]{FFFFFF}{\color[HTML]{333333} EXE} & MEM                         & \multicolumn{1}{c|}{WB}  &                          &                         \\ \cline{3-9}
nop                                   &                         & \multicolumn{1}{c|}{}    & IF                    & ID1                                                & ID2                                                & EXE                         & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB}  &                         \\ \cline{4-10} 
\multicolumn{1}{l}{beq \$1, \$1, label} & \multicolumn{1}{l}{}    & \multicolumn{1}{l}{}     & \multicolumn{1}{l|}{} & IF                                                 & ID1                                                & \cellcolor[HTML]{F8A102}ID2 & \multicolumn{1}{c|}{EXE} & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB} \\ \cline{5-10} 
\end{tabular}
\end{table}

O caso de MEM/WB para ID2 apenas acontece quando existe uma instrução de leitura na memória e em que esse valor lido da memória apenas está disponível em WB e em ID2 está uma operação de beq ou outro tipo que leia um registo que está a para ser escrito pela instrução de lw. Será feito um forward desse valor de MEM/WB para ID2.

\subsection{MEM/WB->MEM}
\begin{table}[!htb]
\centering
\label{my-label}
\begin{tabular}{cc|c|c|c|
>{\columncolor[HTML]{F8A102}}c |
>{\columncolor[HTML]{FFCC67}}c |ccl}
\cline{2-7}
\multicolumn{1}{c|}{lw \$1, 0(\$0)} & IF & ID1 & ID2 & EXE                                                & MEM                                                & WB                          &                         &  &  \\ \cline{2-8}
sw \$1, 0(\$0)                      &    & IF  & ID1 & \cellcolor[HTML]{FFFFFF}{\color[HTML]{000000} ID2} & \cellcolor[HTML]{FFFFFF}{\color[HTML]{333333} EXE} & \cellcolor[HTML]{F8A102}MEM & \multicolumn{1}{c|}{WB} &  &  \\ \cline{3-8}
\end{tabular}
\end{table}

As condições para este caso acontecer são muito específicas, apenas dizem respeito a um lw seguido sw, não diz respeito a uma instrução do tipo R seguida de um sw porque nesse caso é feito o forward de EXE/MEM para EXE para resolver esse caso. Isto só acontece porque o lw só está disponível em MEM, ou seja, para a instrução de sw precisa na fase de MEM desse valor terá de ser feito o forward de MEM/WB para MEM. 
As condições são: em MemRead{\_}Wb==true, MemWrite{\_}Mem==true e WriteReg{\_}wb==rt{\_}mem!=0.

\subsection{Forwarding para EXE}

\begin{table}[!htb]
\centering
\label{my-label}
\begin{tabular}{ccc|c|c|c|
>{\columncolor[HTML]{FFCB2F}}c |ccl}
\cline{2-7}
\multicolumn{1}{c|}{add \$1, \$2, \$3}                       & \multicolumn{1}{c|}{IF} & ID1                   & ID2 & EXE                                                & \cellcolor[HTML]{F8A102}MEM & WB                          &                          &                         &  \\ \cline{2-8}
add \$2, \$1, \$1                                            & \multicolumn{1}{c|}{}   & IF                    & ID1 & \cellcolor[HTML]{FFFFFF}{\color[HTML]{000000} ID2} & \cellcolor[HTML]{F8A102}EXE & MEM                         & \multicolumn{1}{c|}{WB}  &                         &  \\ \cline{3-9}
\multicolumn{1}{l}{{\color[HTML]{009901} add \$2, \$2, \$1}} & \multicolumn{1}{l}{}    & \multicolumn{1}{l|}{} & IF  & ID1                                                & ID2                         & \cellcolor[HTML]{F8A102}EXE & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB} &  \\ \cline{4-9}
\end{tabular}
\end{table}

Neste caso o forwarding é feito desde MEM/WB para EXE e de EXE/MEM para EXE. A instrução que está em EXE necessita dos valores que estão disponíveis na fase de MEM e WB que foram calculados em fases anteriores, sendo assim, é feito o forward para EXE desde MEM/WB e EXE/MEM. Também poderia ocorrer o caso de estar a ser calculado um endereço em EXE de uma instrução do tipo lw ou sw e então ser feito forward para esta fase de um valor que esteja a ser calculado numa das outras fases.

\subsection{Forwarding para ID2}

\begin{table}[!htb]
\centering
\label{my-label}
\begin{tabular}{lccc|c|c|c|ccc}
\cline{2-7}
\multicolumn{1}{l|}{lw \$1, 0(\$0)} & \multicolumn{1}{c|}{IF} & \multicolumn{1}{c|}{ID1} & ID2 & EXE & \cellcolor[HTML]{F8A102}MEM & \cellcolor[HTML]{FFCC67}WB  &                          &                          &                         \\ \cline{2-8}
add \$2,\$3, \$3                   & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{IF}  & ID1 & ID2 & \cellcolor[HTML]{F8A102}EXE & \cellcolor[HTML]{FFCC67}MEM & \multicolumn{1}{c|}{WB}  &                          &                         \\ \cline{3-9}
nop                               &                         & \multicolumn{1}{c|}{}    & IF  & ID1 & ID2                         & EXE                         & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB}  &                         \\ \cline{4-10} 
beq \$1, \$2, label                 &                         &                          &     & IF  & ID1                         & \cellcolor[HTML]{F8A102}ID2 & \multicolumn{1}{c|}{EXE} & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB} \\ \cline{5-10} 
\end{tabular}
\end{table}

\begin{table}[!htb]
\centering
\label{my-label}
\begin{tabular}{lccc|c|c|c|ccc}
\cline{2-7}
\multicolumn{1}{l|}{lw \$1, 0(\$0)} & \multicolumn{1}{c|}{IF} & \multicolumn{1}{c|}{ID1} & ID2 & EXE & \cellcolor[HTML]{F8A102}MEM & \cellcolor[HTML]{FFCC67}WB  &                          &                          &                         \\ \cline{2-8}
add \$2, \$3, \$3                   & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{IF}  & ID1 & ID2 & EXE & MEM & \multicolumn{1}{c|}{WB}  &                          &                         \\ \cline{3-9}
nop                               &                         & \multicolumn{1}{c|}{}    & IF  & ID1 & ID2                         & EXE                         & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB}  &                         \\ \cline{4-10} 
add \$2, \$1, \$2                   &                         &                          &     & IF  & ID1                         & \cellcolor[HTML]{F8A102}ID2 & \multicolumn{1}{c|}{EXE} & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB} \\ \cline{5-10} 
\end{tabular}
\end{table}

\begin{table}[!htb]
\centering
\label{my-label}
\begin{tabular}{lccc|c|c|c|ccc}
\cline{2-7}
\multicolumn{1}{l|}{lw \$1, 0(\$0)} & \multicolumn{1}{c|}{IF} & \multicolumn{1}{c|}{ID1} & ID2 & EXE & \cellcolor[HTML]{F8A102}MEM & \cellcolor[HTML]{FFCC67}WB  &                          &                          &                         \\ \cline{2-8}
nop                               & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{IF}  & ID1 & ID2 & EXE                         & MEM                         & \multicolumn{1}{c|}{WB}  &                          &                         \\ \cline{3-9}
nop                               &                         & \multicolumn{1}{c|}{}    & IF  & ID1 & ID2                         & EXE                         & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB}  &                         \\ \cline{4-10} 
lw \$2, 0(\$1)                      &                         &                          &     & IF  & ID1                         & \cellcolor[HTML]{F8A102}ID2 & \multicolumn{1}{c|}{EXE} & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB} \\ \cline{5-10} 
\end{tabular}
\end{table}

Neste caso assumimos que só está disponível o valor de \$1 quando o lw está na fase de MEM, e este é necessário por uma instrução que vai ler este registo. O valor só vai ser escrito no final de WB, e se o valor for necessário na fase ID2 então teremos de fazer forward. No caso do add, o resultado de um add, este só vai ser gravado quando terminar a fase de WB, no entanto pode ser feito o forward de EXE/MEM para ID2, pois este valor é necessário na fase ID2 (devido ao salto condicional). No caso do lw é necessário fazer o forward de MEM/WB para ID2, porque o valor também ainda não está disponível no banco de registo.

\subsection{Forwarding desde MEM/WB}

\begin{table}[!htb]
\centering
\label{my-label}
\begin{tabular}{lccc|c|c|
>{\columncolor[HTML]{F8A102}}c |ccc}
\cline{2-7}
\multicolumn{1}{l|}{lw \$1, 0(\$0)} & \multicolumn{1}{c|}{IF} & \multicolumn{1}{c|}{ID1} & ID2 & EXE & \cellcolor[HTML]{F8A102}MEM & \cellcolor[HTML]{FFCC67}WB &                          &                          &                         \\ \cline{2-8}
sw \$1, 0(\$0)                      & \multicolumn{1}{c|}{}   & \multicolumn{1}{c|}{IF}  & ID1 & ID2 & EXE                         & MEM                        & \multicolumn{1}{c|}{WB}  &                          &                         \\ \cline{3-9}
add \$2, \$1, \$1                   &                         & \multicolumn{1}{c|}{}    & IF  & ID1 & ID2                         & EXE                        & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB}  &                         \\ \cline{4-10} 
lw \$2, 0(\$1)                      &                         &                          &     & IF  & ID1                         & ID2                        & \multicolumn{1}{c|}{EXE} & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB} \\ \cline{5-10} 
\end{tabular}
\end{table}

Este caso é quando existe um valor que tem de ser lido da memória, ou alguma operação do tipo R que foi calculado na fase de EXE  e é necessário para escrever na memória esse valor, entre a primeira e a segunda instrução existe uma dependência que tem de ser satisfeita através de um forward de MEM/WB para MEM. Outro caso é esse valor ser necessário para a operação que vai decorrer em EXE, fazendo assim um forward de MEM/WB para EXE. Outro caso é existir a necessidade de ler um registo que ainda não foi escrito e que a instrução que escreve nesse ainda não terminou, fazendo assim um forward de MEM/WB para ID2.


\subsection{Testes}
\subsubsection{Teste 1}
Este teste pretende testar o forward de EXE/MEM para EXE e de MEM/WB para EXE.

\begin{table}[!htb]
\centering
\label{my-label}
\begin{tabular}{lcc|c|c|c|c|cc}
\cline{2-7}
\multicolumn{1}{l|}{add \$3, \$1, \$2} & \multicolumn{1}{c|}{IF} & ID1 & ID2 & \cellcolor[HTML]{F8A102}EXE & \cellcolor[HTML]{FFCC67}MEM & \cellcolor[HTML]{FFCC67}WB  &                          &                         \\ \cline{2-8}
add \$4, \$3, \$1                      & \multicolumn{1}{c|}{}   & IF  & ID1 & ID2                         & \cellcolor[HTML]{F8A102}EXE & MEM                         & \multicolumn{1}{c|}{WB}  &                         \\ \cline{3-9} 
add \$5, \$2, \$3                      &                         &     & IF  & ID1                         & ID2                         & \cellcolor[HTML]{F8A102}EXE & \multicolumn{1}{c|}{MEM} & \multicolumn{1}{c|}{WB} \\ \cline{4-9} 
\end{tabular}
\end{table}

O segundo add vai necessitar de ler o \$3 que está a ser calculado  pelo primeiro add e está disponível nas fases MEM e WB. Sendo assim será feito forward de EXE/MEM para EXE para o segundo add e de MEM/WB para EXE por causa do terceiro add.


\newpage
\section{Conclusão}



\end{document}